<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lista 2 — Economia Brasileira</title>
  <style>
    :root{--bg:#0b1020;--card:#10172a;--muted:#b5bfd1;--text:#e8eefc;--accent:#7aa2ff;--ok:#16a34a;--warn:#f59e0b;--err:#ef4444}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji','Segoe UI Emoji';
      background:linear-gradient(180deg,#0b1020 0%,#0f1630 100%); color:var(--text);
      -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none;
    }
    img,canvas{-webkit-user-drag:none; user-select:none}

    .wrap{max-width:1000px; margin:0 auto; padding:24px}
    .card{background:var(--card); border:1px solid rgba(255,255,255,.06); border-radius:16px; padding:20px; box-shadow:0 10px 30px rgba(0,0,0,.35); backdrop-filter:blur(6px)}
    .title{font-size:clamp(20px,3.5vw,32px); font-weight:800; letter-spacing:.4px}
    .muted{color:var(--muted)}
    .row{display:flex; gap:14px; align-items:center; flex-wrap:wrap}
    .btn{appearance:none; border:none; cursor:pointer; border-radius:12px; padding:12px 16px; font-weight:700; color:#0b1020; background:var(--accent); transition:transform .06s ease}
    .btn[disabled]{opacity:.45; cursor:not-allowed}
    .btn:active{transform:translateY(1px)}
    .ghost{background:transparent; color:var(--text); border:1px solid rgba(255,255,255,.16)}

    .qcard{border:1px solid rgba(255,255,255,.08); background:rgba(255,255,255,.02); border-radius:16px; padding:12px}
    .qheader{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px}
    .qtitle{font-weight:800; letter-spacing:.3px}
    .status{font-size:12px; padding:4px 8px; border-radius:8px; background:rgba(255,255,255,.06)}

    .stack{display:grid; gap:16px}
    .nocopy-overlay{position:fixed; inset:0; pointer-events:none; background:repeating-linear-gradient(115deg, rgba(255,255,255,.015) 0, rgba(255,255,255,.015) 2px, transparent 2px, transparent 10px)}

    /* HUD fixo */
    .hud{position:sticky; top:8px; z-index:100; background:rgba(16,23,42,.9); border:1px solid rgba(255,255,255,.10); border-radius:14px; padding:10px 12px; box-shadow:0 8px 24px rgba(0,0,0,.35); backdrop-filter:blur(6px)}
    .hud-row{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap}
    .hud-title{font-weight:800; letter-spacing:.3px}
    .hud-right{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
    .hud-progress{width:260px; max-width:50vw; height:10px; background:rgba(255,255,255,.12); border-radius:999px; overflow:hidden}
    #hudBar{height:100%; width:0%; background:linear-gradient(90deg, var(--accent), #9ad1ff); transition:width .35s ease}
    .tip{font-size:12px; color:var(--muted)}
    @media(max-width:640px){.hud-progress{width:100%; max-width:100%; order:3} .hud-right{gap:8px}}

    /* Debug */
    #debugPanel{display:none; position:fixed; bottom:10px; right:10px; width:320px; max-height:60vh; overflow:auto; padding:12px; border-radius:12px; background:#0c1225; border:1px solid rgba(255,255,255,.15); box-shadow:0 8px 30px rgba(0,0,0,.4); font-size:12px}
    #debugPanel .ok{color:var(--ok)} #debugPanel .fail{color:var(--err)} #debugPanel h4{margin:0 0 8px 0}
  </style>
</head>
<body oncontextmenu="return false" ondragstart="return false" onselectstart="return false">
  <div class="nocopy-overlay" aria-hidden="true"></div>
  <div class="wrap">
    <div id="app"></div>
  </div>
  <div id="debugPanel"><h4>Self-Tests</h4><div id="testList"></div></div>

<script>
// ============================ Configurações ================================
const CONFIG = {
  MINUTES_REQUIRED: 15,        // Tempo mínimo para liberar envio
  LOCK_MINUTES: 15,            // Bloqueio de nova tentativa
  PROF_PASSWORD: 'EBT2',       // Senha para liberar gabarito
  FOCUS_GRACE_MS: 1200         // Tolerância após iniciar (evita falso positivo de perda de foco)
};

// ============================ Anti-cópia ==================================
(function antiCopy(){
  const blockedCombos = [['c'],['x'],['s'],['a'],['p'],['u'],['i'],['j'],['k']];
  document.addEventListener('keydown', (e)=>{
    if ((e.ctrlKey||e.metaKey) && (blockedCombos.some(([k])=>e.key.toLowerCase()===k) || e.shiftKey)) { e.preventDefault(); e.stopPropagation(); }
    if (e.key==='F12' || e.keyCode===44) { e.preventDefault(); e.stopPropagation(); }
  }, {capture:true});
  ['copy','cut','paste','contextmenu'].forEach(ev=>document.addEventListener(ev, e=>{e.preventDefault(); e.stopPropagation();}, {capture:true}));
})();

// ============================ Util ========================================
function fmtTime(ms){ const s=Math.max(0,Math.ceil(ms/1000)); const mm=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return `${mm}:${ss}`; }
function devicePixelRatioSafe(ctx){ const dpr=window.devicePixelRatio||1; const bsr=ctx.backingStorePixelRatio||ctx.webkitBackingStorePixelRatio||ctx.mozBackingStorePixelRatio||ctx.msBackingStorePixelRatio||ctx.oBackingStorePixelRatio||1; return dpr/bsr; }
function fontMetrics(ctx){ const m=ctx.measureText('Mg'); return {ascent:m.actualBoundingBoxAscent||12, descent:m.actualBoundingBoxDescent||4}; }
function baselineCenterY(ctx, baselineY){ const {ascent,descent}=fontMetrics(ctx); return baselineY + (descent - ascent)/2; }
function now(){ return Date.now(); }

// ======================= Questões / Respostas ==============================
// Opções padrão (ordem fixa): 0 BP | 1 Redesconto | 2 Câmbio | 3 Licenc. tarifário | 4 Licenc. quantidade | 5 Inflação | 6 Tributos
const STD_OPTIONS = [
  'Balanço de Pagamentos',
  'Redesconto',
  'Taxa de câmbio',
  'Controle de importações (tarifário)',
  'Controle de importações (por quantidade)',
  'Inflação',
  'Tributos'
];

const QUIZ0 = [
  { id:1, type:'mc', title:'Âncora cambial sob bonança — e a reversão',
    stem:'<em>Governo: Washington Luís (1926–1930). Caixa de Estabilização; paridade fixa; reversão 1928–29.</em> A autoridade mantém paridade fixa e política monetária passiva. Com a piora externa e a parada de capitais, a defesa da paridade exige contração e uso de reservas.',
    options:[...STD_OPTIONS]
  },
  { id:2, type:'mc', title:'Racionamento físico (datas & quotas) — 1931',
    stem:'<em>Governo: Vargas — Provisório (1930–34). Dec. 20.451/1931; monopólio cambial; “datas” e “quotas”.</em> A autoridade centraliza a compra de cambiais e libera <b>importações por licenças físicas</b> (quantidade), com cronogramas (“datas”) e limites por item, priorizando dívida externa e bens essenciais. <b>É controle por quantidade</b>, não por tarifa nem por múltiplas taxas de câmbio.',
    options:[...STD_OPTIONS]
  },
  { id:3, type:'mc', title:'Créditos em marcos que não compram dólares',
    stem:'<em>Governo: Vargas — Constitucional (1934–37). Clearing Brasil–Alemanha (1936).</em> Vendas ao parceiro geram créditos em marcos numa conta de compensação; esses créditos só pagam importações do mesmo parceiro (divisas inconversíveis).',
    options:[...STD_OPTIONS]
  },
  { id:4, type:'mc', title:'Dinheiro demais atrás de poucos bens',
    stem:'<em>Governo: Vargas — Estado Novo (1937–45). II Guerra; M1≈+270%; gargalos de oferta.</em> Importações caem; o governo compra câmbio e injeta base. Sem esterilização, meios de pagamento disparam e os preços sobem.',
    options:[...STD_OPTIONS]
  },
  { id:5, type:'mc', title:'Liberalização inicial; retorno dos controles',
    stem:'<em>Governo: Eurico Gaspar Dutra (1946–1950).</em> Com folga inicial, importações são liberadas; a seguir, o saldo externo se deteriora e os controles de importação retornam.',
    options:[...STD_OPTIONS]
  },
  { id:6, type:'mc', title:'Priorizar por preço, não por quota',
    stem:'<em>Governo: Getúlio Vargas (1951–1954). Lei 1.807/1953; Instrução 70/SUMOC.</em> A autoridade segmenta importações por categorias, barateando essenciais e encarecendo supérfluos por meio de leilões e bonificações.',
    options:[...STD_OPTIONS]
  },
  { id:7, type:'mc', title:'Apertar a torneira do socorro bancário',
    stem:'<em>Governo: Café Filho (1954–1955). Gudin.</em> Para conter a inflação, eleva-se a taxa de redesconto e restringe-se o acesso ao socorro de liquidez de curtíssimo prazo.',
    options:[...STD_OPTIONS]
  },
  { id:8, type:'mc', title:'Conviver com inflação em queda',
    stem:'<em>Governo: Castelo Branco (1964–1967). PAEG — metas 70%→25%→10%; correção monetária.</em> Programa de desinflação gradual com correção monetária e ajuste fiscal para derrubar a inflação em degraus.',
    options:[...STD_OPTIONS]
  }
];

const QUIZ = QUIZ0.filter(q => q.id !== 2);

const ANSWER_KEY = {
  1:{type:'mc', correct:2}, // Câmbio
  2:{type:'mc', correct:4}, // Licenciamento (quantidade)
  3:{type:'mc', correct:0}, // BP
  4:{type:'mc', correct:5}, // Inflação
  5:{type:'mc', correct:4}, // Licenciamento (quantidade)
  6:{type:'mc', correct:2}, // Câmbio (controle por preço via múltiplas taxas)
  7:{type:'mc', correct:1}, // Redesconto
  8:{type:'mc', correct:5}  // Inflação
};

const EXPLAIN = {
  1:['Câmbio fixo (Caixa de Estabilização): a narrativa gira na defesa da paridade; demais efeitos são derivados.'],
  2:['Racionamento físico por licenças/quotas (datas). Instrumento = <b>quantidade</b>; tarifas e múltiplas taxas cambiais são secundárias.'],
  3:['Clearing bilateral com divisas inconversíveis altera uso/composição das receitas externas → Balanço de Pagamentos.'],
  4:['Compra de câmbio sem esterilização + oferta comprimida → canal inflacionário dominante.'],
  5:['Deterioração externa leva ao retorno do licenciamento por quantidade para conter demanda de divisas.'],
  6:['Leilões/bonificações criam múltiplas taxas/prêmios → instrumento cambial (controle por preço).'],
  7:['Ajuste no redesconto (custo/quantidade de liquidez de emergência) é o instrumento central.'],
  8:['Metas e correção monetária: eixo é desinflação/gestão da inflação.']
};

// ====================== Estado do App =====================================
const AppState = {
  started:false,
  startTs:null,
  minMillis: CONFIG.MINUTES_REQUIRED * 60 * 1000,
  answers:{},
  review:false,
  focusGraceUntil:0
};

// ====================== Renderização Base =================================
const appEl = document.getElementById('app');

function renderStart(){
  // Migra/ajusta bloqueio salvo (se maior que o configurado)
  const stored = Number(localStorage.getItem('exam_lock_until')||0);
  if (stored && now() < stored) {
    const desired = now() + CONFIG.LOCK_MINUTES*60*1000;
    if ((stored - now()) > (CONFIG.LOCK_MINUTES*60*1000 + 1000)) {
      localStorage.setItem('exam_lock_until', String(desired));
    }
  }
  const lockedUntil = Number(localStorage.getItem('exam_lock_until')||0);
  const locked = lockedUntil && now() < lockedUntil;
  const remain = Math.max(0, lockedUntil - now());
  appEl.innerHTML = `
    <div class="card" role="region" aria-label="Início da lista">
      <div class="title">Lista 2 — Economia Brasileira</div>
      <p class="muted">• O preenchimento inicia quando você clicar em <b>Iniciar</b>.<br>
      • <b>Tempo mínimo</b> de ${fmtTime(AppState.minMillis)} antes de permitir o envio.<br>
      • O envio somente é liberado com <b>todas</b> as questões respondidas.</p>
      <div class="row">
        <button class="btn" ${locked?'disabled':''} onclick="startExam()">${locked? 'Bloqueado': 'Iniciar'}</button>
        <button class="btn ghost" onclick="location.reload()">Sair</button>
      </div>
      ${locked? `<div class="status" style="margin-top:8px">Nova tentativa em: <b id="lockTimer">${fmtTime(remain)}</b></div>`: ''}
    </div>`;
  if (locked){
    const el = document.getElementById('lockTimer');
    const loop = ()=>{ if (!el) return; const r=Math.max(0, Number(localStorage.getItem('exam_lock_until')) - now()); el.textContent = fmtTime(r); if (r>0) requestAnimationFrame(loop); else renderStart(); };
    requestAnimationFrame(loop);
  }
}

function renderExam(){
  const answeredCount = QUIZ.filter(q=>isAnswered(q)).length;
  const total = QUIZ.length;
  appEl.innerHTML = `
    <div id="hud" class="hud" role="region" aria-label="Painel fixo">
      <div class="hud-row">
        <div class="hud-title">Lista 2 — Economia Brasileira</div>
        <div class="hud-right">
          <div class="status">Tempo: <b id="hudTimer">${fmtTime(AppState.minMillis)}</b></div>
          <div class="hud-progress" aria-hidden="true"><div class="bar" id="hudBar" style="width:0%"></div></div>
          <div class="tip" id="hudProgressText">Progresso: ${answeredCount}/${total} respondidas</div>
          <button class="btn ghost" onclick="if(confirm('Reiniciar? As respostas serão perdidas.')) location.reload()">Reiniciar</button>
        </div>
      </div>
    </div>
    <div class="card" role="region" aria-label="Lista 2">
      <div class="stack" id="qstack"></div>
      <div class="row" style="justify-content:flex-end;margin-top:14px">
        <button id="submitBtn" class="btn" disabled onclick="submitExam()">Enviar respostas</button>
      </div>
    </div>`;
  const holder = document.getElementById('qstack');
  QUIZ.forEach((q, idx)=>{
    const card=document.createElement('div'); card.className='qcard';
    card.innerHTML = `
      <div class="qheader">
        <div class="qtitle">Questão ${idx+1} — ${q.title}</div>
        <div class="status" id="status-${q.id}">${isAnswered(q)?'Respondida':'Em aberto'}</div>
      </div>
      <canvas id="canvas-${q.id}" width="900" height="200" style="width:100%; height:auto; display:block; border-radius:12px; background:rgba(255,255,255,.02)"></canvas>`;
    holder.appendChild(card);
    drawQuestion(q, 'exam');
  });
}

function render(){ AppState.started ? renderExam() : renderStart(); }

// ========================== Fluxo principal ================================
function startExam(){
  const until = Number(localStorage.getItem('exam_lock_until')||0);
  if (until && now()<until){ alert('Nova tentativa bloqueada. Aguarde: '+fmtTime(until-now())); return; }
  AppState.started = true; AppState.startTs = now();
  AppState.focusGraceUntil = now() + CONFIG.FOCUS_GRACE_MS;
  render(); tick();
}

function resetExam(reason=''){
  AppState.started=false; AppState.startTs=null; AppState.review=false; AppState.answers={}; sessionStorage.removeItem('review_unlocked');
  renderStart();
}

function handleFocusLoss(reason){
  if (!AppState.started) return;
  if (now() < AppState.focusGraceUntil) return;
  resetExam(reason);
  setTimeout(()=>alert('A janela perdeu o foco. O teste foi reiniciado.'),0);
}

document.addEventListener('visibilitychange', ()=>{ if (document.hidden) handleFocusLoss('visibility'); });
window.addEventListener('blur',  ()=> handleFocusLoss('blur'));
window.addEventListener('pagehide',  ()=> handleFocusLoss('pagehide'));
document.addEventListener('freeze',  ()=> handleFocusLoss('freeze'));

function allAnswered(){
  return QUIZ.every(q=>{
    const a = AppState.answers[q.id];
    if (q.type==='mc') return typeof a === 'number';
    if (q.type==='vf') return a && Array.isArray(a.bools) && a.bools.length===q.statements.length && a.bools.every(v=>typeof v==='boolean');
    return false;
  });
}

function timeOk(){ if (!AppState.startTs) return false; return (now()-AppState.startTs) >= AppState.minMillis; }

function submitExam(){
  if (!allAnswered()) { alert('Resolução incompleta: responda todas as questões.'); return; }
  if (!timeOk()) { alert(`Tempo mínimo de ${fmtTime(AppState.minMillis)} ainda não cumprido.`); return; }
  const lockUntil = now() + CONFIG.LOCK_MINUTES*60*1000; localStorage.setItem('exam_lock_until', String(lockUntil));
  AppState.review = true; AppState.started = false; renderReview();
}

function tick(){
  const timerEl = document.getElementById('hudTimer');
  const barEl = document.getElementById('hudBar');
  const submitBtn = document.getElementById('submitBtn');
  if (timerEl && AppState.startTs){
    const elapsed = now()-AppState.startTs; const remain = Math.max(0, AppState.minMillis - elapsed);
    timerEl.textContent = fmtTime(remain);
    const pct = Math.min(100, Math.floor( (elapsed/AppState.minMillis)*100 ));
    if (barEl) barEl.style.width = pct + '%';
  }
  if (submitBtn) submitBtn.disabled = (!timeOk() || !allAnswered());
  if (AppState.started) requestAnimationFrame(tick);
}

// ============================ Desenho ======================================
const HitMap = new Map(); // qid -> { type, boxes:[...] }

function wrapText(ctx, text, x, y, maxWidth, lineHeight){
  const words=(String(text)).replace(/<[^>]+>/g,'').split(/\s+/); let line=''; const lines=[];
  for (let n=0;n<words.length;n++){ const test=line+words[n]+' '; const w=ctx.measureText(test).width; if (w>maxWidth && n>0){ lines.push(line.trim()); line=words[n]+' '; } else { line=test; } }
  lines.push(line.trim());
  for (const ln of lines){ ctx.fillText(ln, x, y); y += lineHeight; }
  return y;
}

function drawVFBox(ctx, x, y, label){ ctx.save(); ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=2; const w=36,h=24; ctx.strokeRect(x,y,w,h); ctx.font='bold 14px Inter, system-ui, Arial'; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillText(label, x+(w/2-5), y+(h/2+5)); ctx.restore(); }
function drawCrossAt(ctx, cx, cy, size=16, color='#ef4444'){ ctx.save(); ctx.strokeStyle=color; ctx.lineWidth=2.5; const r=size/2; ctx.beginPath(); ctx.moveTo(cx-r, cy-r); ctx.lineTo(cx+r, cy+r); ctx.moveTo(cx+r, cy-r); ctx.lineTo(cx-r, cy+r); ctx.stroke(); ctx.restore(); }
function drawCheckAt(ctx, cx, cy, size=16, color='#16a34a'){ ctx.save(); ctx.strokeStyle=color; ctx.lineWidth=3; const r=size/2; ctx.beginPath(); ctx.moveTo(cx - r*0.6, cy + r*0.1); ctx.lineTo(cx - r*0.2, cy + r*0.5); ctx.lineTo(cx + r*0.6, cy - r*0.5); ctx.stroke(); ctx.restore(); }
function drawHighlight(ctx, x, y, w, h, rgba){ ctx.save(); ctx.fillStyle=rgba; ctx.fillRect(x,y,w,h); ctx.restore(); }

function drawQuestion(q, mode='exam'){
  const canvas = document.getElementById(`canvas-${q.id}`); const ctx = canvas.getContext('2d');
  const key = ANSWER_KEY[q.id]; const userAns = AppState.answers[q.id];

  const scale = devicePixelRatioSafe(ctx); const cssWidth = canvas.clientWidth || 900; const baseW = Math.min(900, cssWidth); const padding=20; const contentW=baseW - padding*2;

  // Medição
  ctx.setTransform(1,0,0,1,0,0); canvas.width = baseW * scale; ctx.setTransform(scale,0,0,scale,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='rgba(255,255,255,0.92)'; ctx.font='600 16px Inter, system-ui, Arial'; let x=padding, y=padding+6; y = wrapText(ctx, q.stem, x, y, contentW, 22) + 8;
  ctx.font='15px Inter, system-ui, Arial'; ctx.fillStyle='rgba(255,255,255,0.9)';
  (q.options||[]).forEach((opt,i)=>{ const oy=y; y = wrapText(ctx, `(${String.fromCharCode(97+i)}) `+opt, x+32, oy, contentW-40, 20) + 6; });
  const neededH = y + padding; canvas.height = neededH * scale; ctx.setTransform(scale,0,0,scale,0,0); ctx.clearRect(0,0,canvas.width,canvas.height);

  // Desenho final
  HitMap.set(q.id, { type:q.type, boxes:[] });
  const map = HitMap.get(q.id);

  ctx.fillStyle='rgba(255,255,255,0.92)'; ctx.font='600 16px Inter, system-ui, Arial'; x=padding; y=padding+6; y = wrapText(ctx, q.stem, x, y, contentW, 22) + 8;
  ctx.font='15px Inter, system-ui, Arial'; ctx.fillStyle='rgba(255,255,255,0.9)';

  const sel = userAns;
  q.options.forEach((opt,i)=>{
    const oy=y; const r=8; const cx=x+12; const cy=baselineCenterY(ctx, oy);
    // radio outline
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.7)'; ctx.lineWidth=2; ctx.stroke();
    // selecionado (modo exame)
    if (typeof sel==='number' && sel===i && mode!=='review'){
      ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI*2); ctx.fillStyle='white'; ctx.fill(); ctx.restore();
    }
    const ox=x+32; ctx.fillStyle='rgba(255,255,255,0.9)';
    y = wrapText(ctx, `(${String.fromCharCode(97+i)}) `+opt, ox, oy, contentW-40, 20) + 6;

    // hitboxes
    map.boxes.push({kind:'mc-radio', idx:i, x:cx-14, y:cy-14, w:28, h:28});
    map.boxes.push({kind:'mc-text',  idx:i, x:ox,    y:oy-8,  w:contentW-(ox-x), h:(y-oy)+10});

    // review visuals
    if (mode==='review' && key){
      if (typeof sel==='number' && sel===i && sel===key.correct){
        drawHighlight(ctx, x+2, oy-8, contentW-4, (y-oy)+10, 'rgba(22,163,74,0.18)');
        ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI*2); ctx.fillStyle='#16a34a'; ctx.fill(); ctx.restore();
      } else if (typeof sel==='number' && sel===i && sel!==key.correct){
        drawCrossAt(ctx, cx, cy, 18, '#ef4444');
      }
      if (typeof sel==='number' && sel!==key.correct && i===key.correct){
        drawCheckAt(ctx, cx, cy, 18, '#16a34a');
      }
    }
  });

  // clique
  canvas.onclick = function(ev){
    if (mode==='review') return;
    const rect = canvas.getBoundingClientRect(); const px=(ev.clientX-rect.left); const py=(ev.clientY-rect.top); const mapLocal = HitMap.get(q.id) || {boxes:[]}; if (!mapLocal.boxes.length) return;
    let box=null; for (let i=mapLocal.boxes.length-1;i>=0;i--){ const b=mapLocal.boxes[i]; if (px>=b.x && px<=b.x+b.w && py>=b.y && py<=b.y+b.h){ box=b; break; } }
    if (!box) return;
    if (box.kind==='mc-radio' || box.kind==='mc-text'){ AppState.answers[q.id] = box.idx; }
    const st=document.getElementById(`status-${q.id}`); if (st) st.textContent = isAnswered(q)?'Respondida':'Em aberto';
    drawQuestion(q,'exam'); const submitBtn=document.getElementById('submitBtn'); if (submitBtn) submitBtn.disabled = (!timeOk() || !allAnswered());
    const answeredCount=QUIZ.filter(qq=>isAnswered(qq)).length; const hudTxt = document.getElementById('hudProgressText'); if (hudTxt) hudTxt.textContent = `Progresso: ${answeredCount}/${QUIZ.length} respondidas`;
  };
}

function isAnswered(q){ const a=AppState.answers[q.id]; if (q.type==='mc') return typeof a==='number'; if (q.type==='vf') return a && Array.isArray(a.bools) && a.bools.length===q.statements.length && a.bools.every(v=>typeof v==='boolean'); return false; }

// ====================== Revisão (Gabarito) ================================
function getExplainHTML(qid){ const arr=EXPLAIN[qid]||[]; return arr.length? '<ul>'+arr.map(s=>`<li>${s}</li>`).join('')+'</ul>' : '—'; }

function computeScore(){ let correctQ=0,totalQ=QUIZ.length; QUIZ.forEach(q=>{ const a=AppState.answers[q.id]; const k=ANSWER_KEY[q.id]; if (!a||!k) return; if (q.type==='mc'){ if (typeof a==='number' && a===k.correct) correctQ++; } }); return {correctQ,totalQ}; }

function renderReview(){
  // Gate de senha
  if (sessionStorage.getItem('review_unlocked')!=='1'){
    appEl.innerHTML = `
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;gap:12px;margin-bottom:8px">
          <div class="title">Gabarito — Acesso Restrito</div>
        </div>
        <p class="muted">Digite a senha para liberar o gabarito e a revisão visual.</p>
        <div class="row" style="gap:8px">
          <input id="profPass" type="password" placeholder="Senha" style="flex:1; padding:10px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.04); color:#fff;">
          <button class="btn" id="unlockBtn">Liberar</button>
          <button class="btn ghost" onclick="location.reload()">Voltar</button>
        </div>
      </div>`;
    document.getElementById('unlockBtn').onclick = ()=>{ const v=(document.getElementById('profPass').value||'').trim(); if (v===CONFIG.PROF_PASSWORD){ sessionStorage.setItem('review_unlocked','1'); renderReview(); } else alert('Senha incorreta.'); };
    return;
  }

  const score = computeScore();
  appEl.innerHTML = `
    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:center;gap:12px;margin-bottom:8px">
        <div class="title">Gabarito e Revisão</div>
        <div class="row"><button class="btn ghost" onclick="location.reload()">Fechar</button></div>
      </div>
      <div class="tip" style="margin-bottom:10px">Você acertou <b>${score.correctQ}</b> de <b>${score.totalQ}</b> questões (${Math.round(100*score.correctQ/score.totalQ)}%).</div>
      <div class="stack" id="qstack"></div>
    </div>`;

  const holder = document.getElementById('qstack');
  QUIZ.forEach((q, idx)=>{
    const card=document.createElement('div'); card.className='qcard';
    card.innerHTML = `
      <div class="qheader">
        <div class="qtitle">Questão ${idx+1} — ${q.title} <span class="status">Gabarito</span></div>
      </div>
      <canvas id="canvas-${q.id}" width="900" height="200" style="width:100%; height:auto; display:block; border-radius:12px; background:rgba(255,255,255,.02)"></canvas>
      <details style="margin-top:8px">
        <summary>Referências & justificativas</summary>
        <div class="muted" style="margin-top:6px">${getExplainHTML(q.id)}</div>
      </details>`;
    holder.appendChild(card);
    drawQuestion(q,'review');
  });
}

// ====================== Self Tests (não alteram lógica) ===================
const TESTS = [];
function tassert(name, cond){ TESTS.push({name, ok: !!cond}); }
function runSelfTests(){
  try{
    // Qtd de questões = 8
    tassert('Total de questões = 7', QUIZ.length===7);
    // Todas as questões têm 7 alternativas
    tassert('Todas as questões com 7 alternativas', QUIZ.every(q=>q.options && q.options.length===7));
    // Gate de senha presente
    sessionStorage.removeItem('review_unlocked'); renderReview(); const gate = !!document.getElementById('profPass'); tassert('Gate de senha presente', gate);
    // Timer configurado
    tassert('Tempo mínimo = 15 minutos', CONFIG.MINUTES_REQUIRED*60*1000 === 900000);
    tassert('Bloqueio = 15 minutos', CONFIG.LOCK_MINUTES*60*1000 === 900000);
  }catch(e){ tassert('Self-tests executados sem exceção', false); }
  renderTestPanel();
  // Restaura a tela correta após os testes
  render();
}
function renderTestPanel(){
  const show = (new URLSearchParams(location.search)).get('debug')==='1';
  const panel = document.getElementById('debugPanel'); const list = document.getElementById('testList'); if (!panel||!list) return;
  list.innerHTML = TESTS.map(t=>`<div class="${t.ok?'ok':'fail'}">${t.ok?'✔':'✖'} ${t.name}</div>`).join('');
  if (show) panel.style.display='block';
}
(function enableTestHotkey(){
  let dCount=0; document.addEventListener('keydown', (e)=>{ if (e.key.toLowerCase()==='d'){ dCount++; if (dCount>=3){ const p=document.getElementById('debugPanel'); if (p) p.style.display = (p.style.display==='block'?'none':'block'); dCount=0; } setTimeout(()=>dCount=0,600); } }, {capture:true});
})();

// ===================== Inicialização ======================================
function init(){ renderStart(); runSelfTests(); }
window.startExam = startExam; window.submitExam = submitExam; window.drawQuestion = drawQuestion; window.renderReview = renderReview; window.resetExam = resetExam;
init();
</script>
</body>
</html>

